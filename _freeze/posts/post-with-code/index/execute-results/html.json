{
  "hash": "4cca9393a53ac072417aa899b513b6ca",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Data-first mentality.\"\nauthor: \"Giordano Rogers\"\ndate: \"2025-01-02\"\ncategories: [programming, philosophy]\nimage: \"image.jpg\"\n---\n\n\nCalling Python \"Excel on steroids without the UI\" sells it short. But the framing has merit. Python, like Excel, is a tool to process data.\n\nThe term 'programming language' shapes how we view tools like Python. We often forget that languages are tools. Language turns thought into communication. It's so good at this that we tend to confuse the words with the thoughts temselves. Thus we conflate our vocabulary with our identity\n\nThe same blind spot distorts how programmers view coding languages. To build great software, we should view code less like poetry and more like a campfire. There are efficient and inefficient ways to stack firewood, but the fire—not the wood—is what matters most.\n\nProgrammers often mistake mastery of syntax for mastery of software. We feel accomplished when we learn a new library or expression. But being a great linguist doesn’t make someone a great communicator. Likewise, great code doesn’t guarantee great software. \n\nSoftware revolves around handling data, and data is hard to control. First, you have to get the right data---maybe from users, or the internet. Then you have to transform that data into something useful---maybe a UI, or meaningful statistics.\n\nWhen we think about coding, many of us imagine building 'things'. In reality, we're automating and optimizing processes. Using Excel to make cell C1 divide cell A1 by cell B1 isn't groundbreaking. But show a non-developer some resilient code that does the same, and they’ll think it’s magic.\n\n::: {#a0128136 .cell execution_count=1}\n``` {.python .cell-code}\nimport logging\nfrom typing import Union\n\nlogging.basicConfig(level=logging.INFO)\n\ndef divide_two_numbers(numerator: Union[int, float], denominator: Union[int, float]) -> float:\n    \"\"\"Perform division between two numeric values.\n\n    Args:\n        numerator (Union[int, float]): The number to be divided.\n        denominator (Union[int, float]): The number to be divided by.\n\n    Returns:\n        float: The result of dividing `numerator` by `denominator`.\n\n    Raises:\n        TypeError: If either input is not a number.\n        ValueError: If attempting to divide by zero.\n    \"\"\"\n    logging.info(\"Initiating the division process.\")\n\n    # Type validation\n    if not isinstance(numerator, (int, float)):\n        raise TypeError(f\"Invalid type for 'numerator': {type(numerator).__name__}. Expected int or float.\")\n    if not isinstance(denominator, (int, float)):\n        raise TypeError(f\"Invalid type for 'denominator': {type(denominator).__name__}. Expected int or float.\")\n\n    # Check for division by zero\n    if denominator == 0:\n        logging.error(\"Attempted division by zero. This operation is undefined.\")\n        raise ValueError(\"Denominator cannot be zero.\")\n\n    logging.info(f\"Inputs validated: numerator={numerator}, denominator={denominator}. Proceeding with division.\")\n    result = numerator / denominator\n    logging.info(f\"Division completed. Result: {result}\")\n    return result\n\nnumerator = 10.0\ndenominator = 2.0\n\ntry:\n    division_result = divide_two_numbers(numerator, denominator)\n    print(division_result)\nexcept Exception as e:\n    logging.error(f\"An error occurred during division: {e}\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nINFO:root:Initiating the division process.\nINFO:root:Inputs validated: numerator=10.0, denominator=2.0. Proceeding with division.\nINFO:root:Division completed. Result: 5.0\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n5.0\n```\n:::\n:::\n\n\nThis toy example illustrates how a simple task can look complex in code. The input and output of the Excel function and this Python function could be identical. But the Python code looks arcane. It carries a mystique that tends to become a source of inflated pride in coders.\n\nLearning a programming language takes significant effort. When you finally write good software, it feels like you’ve passed an initiation into an exclusive club. In a way, you have.\n\nBut remember, the code itself isn’t what matters most. The data does.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}