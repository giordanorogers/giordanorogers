{"title":"Fourier Series for Modeling Melody","markdown":{"yaml":{"title":"Fourier Series for Modeling Melody","author":"Giordano Rogers","date":"2025-01-04","categories":["music","math"],"image":"fourier_graph.svg"},"headingText":"Define the melody as integers","containsRefs":false,"markdown":"\n\n\nA function is mapping of an object in a set to some output.\n\nThe musical notes are a set.\n\nA musical scale is a more narrow set.\n\nAnd rhythms and progressions can be codified down to a generative algorithm.\n\nFor example, take the melody for \"Mary Had a Little Lamb\"\n\nEDCDEEEDDDEGGEDCDEEEEDDEDC\n\nCan we create a function f(x) that computes the proper note if we treat x as the\nnote's index in the sequence?\n\nWhat about a simpler harmony first.\n\n```{=html}\n<audio controls>\n  <source src=\"EGEC.wav\" type=\"audio/wav\">\n  Your browser does not support the audio element.\n</audio>\n```\n\nThis is a walk up and down the C major chord. We start at E, then up three\nhalf-notes to G, back to E, down three half-notes to C, and then back to E.\n\nIf we express each bar of a four bar loop as a zero indexed array, then we\ncan model this melody as mathematically as the function:\n\n$$\nf(x) = 4 + 3\\sin(\\frac{\\pi}{2}x)\n$$\n\nOr, in python:\n\n```{python}\nfrom math import sin, pi\n\ndef egec(index):\n    note = 4 + 3 * sin((pi / 2) * index)\n    return round(note)\n\nnote_list = [egec(index) for index in range(8)]\nprint(note_list)\n```\n\nAnd we can graph this melody like so:\n\n![Graph of the EGEC melody function](cool_graph.svg)\n\nIt shouldn't be surprising that we can graph simple melodies like this as sine curves. After all, the MIDI notes on my piano roll in Ableton Live look just like the graph:\n\n![MIDI piano roll of EGEC melody](egec.png)\n\nWhat's interesting about this is that any melody we can functionalize like this,\nwe can generate programmatically.\n\nThink about the whole world of automated music we can make if we can define our\nmelodic taste in such a formal way.\n\nNow obviously, this simple melody would get very boring after some time.\n\nLet's return to thinking about the Mary Had A Little Lamb melody.\n\nHere are the notes again:\n\nEDCDEEEDDDEGGEDCDEEEEDDEDC\n\nHere it is as played on the piano:\n\n```{=html}\n<audio controls>\n  <source src=\"mary_had_a_little_lambd.wav\" type=\"audio/wav\">\n  Your browser does not support the audio element.\n</audio>\n```\n\nThis melody is not as periodic as the EGEC melody, but there's still enough of\na pattern to it that we can intuitively sense that there must be some way to\nmap it to a function.\n\nLuckily, a similar logic applies.\n\nJust like we used a sin wave to model the transitions in the EGEC melody, we\ncan combine several sin wavs to approximate a function that will get us our\nMary Had A Little Lamb melody too.\n\nThis will involve using the power of the Fourier series.\n\nA Fourier series can approximate any periodic function by summing sine and\ncosine terms.\n\nEven though the Mary Had a Lamb melody isn't periodic, we can \"force\" periodicity by repeating the sequence and using Fourier coefficients to approximate the pattern.\n\n```{python}\nfrom numpy import arange, linspace, cos, sin, mean\n\nmelody = [4, 2, 0, 2, 4, 4, 4, 2, 2, 2, 4, 7, 7,\n          4, 2, 0, 2, 4, 4, 4, 4, 2, 2, 4, 2, 0]\nN = len(melody)  # Number of terms in the melody\nx_vals = arange(0, N)  # Melody indices\n\n# Extend melody for visualization\nrepeats = 3\nextended_melody = melody * repeats\nextended_x_vals = arange(0, N * repeats)\n\n# Compute Fourier series approximation\ndef fourier_series(x, num_terms=10):\n    a0 = mean(melody)  # Mean value (DC component)\n    approx = a0  # Start with the DC component\n    for n in range(1, num_terms + 1):\n        an = (2 / N) * sum(melody * \\\n          cos(2 * pi * n * x_vals / N))\n        bn = (2 / N) * sum(melody * \\\n          sin(2 * pi * n * x_vals / N))\n        approx += an * cos(2 * pi * n * x / N) + \\\n          bn * sin(2 * pi * n * x / N)\n    return approx\n\n# Generate Fourier approximation\nx_approx = linspace(0, N * repeats, 1000)  # Smooth x values\ny_approx = fourier_series(x_approx)\n\n# Generate discrete indices for approximation\ndiscrete_indices = arange(0, N * repeats)  # Integer indices\n\n# Compute Fourier series and round to nearest whole number\ny_discrete_approx = [round(fourier_series(x))\n                     for x in discrete_indices]\n\n# Print the first 16 approximated notes\nprint(\"First 16 Notes of Mary Had a Little Lamb\")\nprint(\"\\nFourier Approximation (Rounded):\")\nprint(y_discrete_approx[:16])\nprint(\"\\nOriginal Melody:\")\nprint(extended_melody[:16])\n```\n\nAnd we can view the graph of the approximated curve too:\n\n![Graph of the Mary Had a Little Lamb melody](fourier_graph.svg)\n\nAnd if we zoom in the graph a bit to see the first cycle of the melody:\n\n![Graph of the first cycle of the Mary Had a Little Lamb melody](fourier_zoomed_graph.svg)\n\nAnd as we'd expect, we can see that it looks pretty similar to the piano roll of the midi notes for Mary Had a Little Lamb that I recorded in Ableton Live:\n\n![MIDI piano roll for Mary Had a Little Lamb](mary_lamb_roll2.png)\n\nAgain though, this Mary Had a Little Lamb melody is very simple compared to the\nmelodies in most of the music people tend to listen to.\n\nBut the beauty of the Fourier series is that we can create curves for many\ndifferent melodies using this same technique, and then we can adjust the curves\nby changing a few parameters, and generate similar but novel melodies with our \nnew adapted curves.\n\nAs a more advanced step, we could combine Fourier methods with neural networks \nto capture non-period and stylistic elements.","srcMarkdownNoYaml":"\n\n\nA function is mapping of an object in a set to some output.\n\nThe musical notes are a set.\n\nA musical scale is a more narrow set.\n\nAnd rhythms and progressions can be codified down to a generative algorithm.\n\nFor example, take the melody for \"Mary Had a Little Lamb\"\n\nEDCDEEEDDDEGGEDCDEEEEDDEDC\n\nCan we create a function f(x) that computes the proper note if we treat x as the\nnote's index in the sequence?\n\nWhat about a simpler harmony first.\n\n```{=html}\n<audio controls>\n  <source src=\"EGEC.wav\" type=\"audio/wav\">\n  Your browser does not support the audio element.\n</audio>\n```\n\nThis is a walk up and down the C major chord. We start at E, then up three\nhalf-notes to G, back to E, down three half-notes to C, and then back to E.\n\nIf we express each bar of a four bar loop as a zero indexed array, then we\ncan model this melody as mathematically as the function:\n\n$$\nf(x) = 4 + 3\\sin(\\frac{\\pi}{2}x)\n$$\n\nOr, in python:\n\n```{python}\nfrom math import sin, pi\n\ndef egec(index):\n    note = 4 + 3 * sin((pi / 2) * index)\n    return round(note)\n\nnote_list = [egec(index) for index in range(8)]\nprint(note_list)\n```\n\nAnd we can graph this melody like so:\n\n![Graph of the EGEC melody function](cool_graph.svg)\n\nIt shouldn't be surprising that we can graph simple melodies like this as sine curves. After all, the MIDI notes on my piano roll in Ableton Live look just like the graph:\n\n![MIDI piano roll of EGEC melody](egec.png)\n\nWhat's interesting about this is that any melody we can functionalize like this,\nwe can generate programmatically.\n\nThink about the whole world of automated music we can make if we can define our\nmelodic taste in such a formal way.\n\nNow obviously, this simple melody would get very boring after some time.\n\nLet's return to thinking about the Mary Had A Little Lamb melody.\n\nHere are the notes again:\n\nEDCDEEEDDDEGGEDCDEEEEDDEDC\n\nHere it is as played on the piano:\n\n```{=html}\n<audio controls>\n  <source src=\"mary_had_a_little_lambd.wav\" type=\"audio/wav\">\n  Your browser does not support the audio element.\n</audio>\n```\n\nThis melody is not as periodic as the EGEC melody, but there's still enough of\na pattern to it that we can intuitively sense that there must be some way to\nmap it to a function.\n\nLuckily, a similar logic applies.\n\nJust like we used a sin wave to model the transitions in the EGEC melody, we\ncan combine several sin wavs to approximate a function that will get us our\nMary Had A Little Lamb melody too.\n\nThis will involve using the power of the Fourier series.\n\nA Fourier series can approximate any periodic function by summing sine and\ncosine terms.\n\nEven though the Mary Had a Lamb melody isn't periodic, we can \"force\" periodicity by repeating the sequence and using Fourier coefficients to approximate the pattern.\n\n```{python}\nfrom numpy import arange, linspace, cos, sin, mean\n\n# Define the melody as integers\nmelody = [4, 2, 0, 2, 4, 4, 4, 2, 2, 2, 4, 7, 7,\n          4, 2, 0, 2, 4, 4, 4, 4, 2, 2, 4, 2, 0]\nN = len(melody)  # Number of terms in the melody\nx_vals = arange(0, N)  # Melody indices\n\n# Extend melody for visualization\nrepeats = 3\nextended_melody = melody * repeats\nextended_x_vals = arange(0, N * repeats)\n\n# Compute Fourier series approximation\ndef fourier_series(x, num_terms=10):\n    a0 = mean(melody)  # Mean value (DC component)\n    approx = a0  # Start with the DC component\n    for n in range(1, num_terms + 1):\n        an = (2 / N) * sum(melody * \\\n          cos(2 * pi * n * x_vals / N))\n        bn = (2 / N) * sum(melody * \\\n          sin(2 * pi * n * x_vals / N))\n        approx += an * cos(2 * pi * n * x / N) + \\\n          bn * sin(2 * pi * n * x / N)\n    return approx\n\n# Generate Fourier approximation\nx_approx = linspace(0, N * repeats, 1000)  # Smooth x values\ny_approx = fourier_series(x_approx)\n\n# Generate discrete indices for approximation\ndiscrete_indices = arange(0, N * repeats)  # Integer indices\n\n# Compute Fourier series and round to nearest whole number\ny_discrete_approx = [round(fourier_series(x))\n                     for x in discrete_indices]\n\n# Print the first 16 approximated notes\nprint(\"First 16 Notes of Mary Had a Little Lamb\")\nprint(\"\\nFourier Approximation (Rounded):\")\nprint(y_discrete_approx[:16])\nprint(\"\\nOriginal Melody:\")\nprint(extended_melody[:16])\n```\n\nAnd we can view the graph of the approximated curve too:\n\n![Graph of the Mary Had a Little Lamb melody](fourier_graph.svg)\n\nAnd if we zoom in the graph a bit to see the first cycle of the melody:\n\n![Graph of the first cycle of the Mary Had a Little Lamb melody](fourier_zoomed_graph.svg)\n\nAnd as we'd expect, we can see that it looks pretty similar to the piano roll of the midi notes for Mary Had a Little Lamb that I recorded in Ableton Live:\n\n![MIDI piano roll for Mary Had a Little Lamb](mary_lamb_roll2.png)\n\nAgain though, this Mary Had a Little Lamb melody is very simple compared to the\nmelodies in most of the music people tend to listen to.\n\nBut the beauty of the Fourier series is that we can create curves for many\ndifferent melodies using this same technique, and then we can adjust the curves\nby changing a few parameters, and generate similar but novel melodies with our \nnew adapted curves.\n\nAs a more advanced step, we could combine Fourier methods with neural networks \nto capture non-period and stylistic elements."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"highlight-style":"github-dark","output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.39","theme":["cyborg","../../custom.scss"],"fontsize":"1.3em","monofont":"Courier","title-block-banner":true,"title":"Fourier Series for Modeling Melody","author":"Giordano Rogers","date":"2025-01-04","categories":["music","math"],"image":"fourier_graph.svg"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}