{
  "hash": "15a1f865d1db8bc6cef21ad03e1defab",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Semantic Similarity\"\nauthor: \"Giordano Rogers\"\ndate: \"2025-01-04\"\ncategories: [NLP, math]\nimage: \"\"\n---\n\n\nPart of why natural language processing appeals to me is the prospect of being\nable to compare two bodies of text mathematically.\n\nLately I've been building a an app that generates newsletter summarizations of\nemerging research.\n\nBut I've been asking myself how I can improve the paper filtering.\n\nAs of now, let's say on a given day my app collects 100 papers from my research\nfield.\n\nEven if all of these papers were summarized to a single sentence, I wouldn't want\nto read all that.\n\nSo we need a way to automate the selection process, so that the three to five\npapers I see when I open up my email, are ones that I'm actually interested in.\n\nOne very simply approach would be to keep a list of keywords, and to check if\nany of the papers have abstracts that contain one of my keywords.\n\nAn issue with this is the problem of synonyms.\n\nWhat if I'm very interested in signal processing for music, and I decide to use\nthe keywords\n\n::: {#22de43f3 .cell execution_count=1}\n``` {.python .cell-code}\ndef keyword_search(\n    abstracts, keywords = [\"signal processing\", \"music\"]\n    ):\n    selected_abstracts = []\n    for abstract in abstracts:\n        for keyword in keywords:\n            if keyword in abstract.strip().lower():\n                selected_abstracts.append(abstract)\n    return selected_abstracts\n```\n:::\n\n\nLet's say an amazing new paper drops introducing a revolutionary new algorithm\nfor musical signal processing, but the abstract only uses the common acronym\nDSP, for digital signal processing, rather than the whole word? What if instead\nof \"music\" they use synonys like \"melody\" or \"instrumental\"?\n\nIn that case, my simple string search method for selection wouldn't work.\n\nAlthough the keyword search technically does fall under the branch of natural\nlanguage processing, it is a very rudimentary approach and we have much better\nways to perform this task.\n\nThe most common method currently is cosine similarity.\n\nThis involves converting two pieces of texts you want to compare into their own\nvector representaitons using LLM embeddings, and then computing the angle \nbetween the two vectors.\n\nThe mathematical formula for cosine similarity:\n\n$$\n\\cos(\\theta) = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{ \\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert}\n$$\n\nIn python:\n\n::: {#91bd48d6 .cell execution_count=2}\n``` {.python .cell-code}\nfrom numpy import dot, linalg\n\ndef cosine_similarity(a, b):\n  a_dot_b = dot(a, b)\n  a_norm = linalg.norm(a)\n  b_norm = linalg.norm(b)\n  return a_dot_b / (a_norm * b_norm)\n```\n:::\n\n\nImplementation is stripped down for readability and teaching purposes, but fundamentally this is the essence of cosine similarity. It is surprising how much can be achieved with such a simple function.\n\nAs a toy example, consider we have three simplified vectors that represent three words.\n\n::: {#3e765daa .cell execution_count=3}\n``` {.python .cell-code}\nfrom numpy import random\n\ndog = random.normal(9, 0.1, 10)\ncat = random.normal(9, 0.1, 10)\nchocolate = random.normal(-1, 0.1, 10)\n```\n:::\n\n\nIn practice, these vectors would be much longer, and we may be comparing whole paragraphs or documents rather than just single words. But we can look at this example and, both in language and in math, intuit that the first two terms are more similar than to eachother than either is to the third.\n\nUsing our cosing similarity function, we can calcualte this similarity.\n\n::: {#053ffe28 .cell execution_count=4}\n``` {.python .cell-code}\nfrom numpy import dot, linalg, random\n\ndef cosine_similarity(a, b):\n  a_dot_b = dot(a, b)\n  a_norm = linalg.norm(a)\n  b_norm = linalg.norm(b)\n  return a_dot_b / (a_norm * b_norm)\n\nrandom.seed(69)\ndog = random.normal(9, 0.1, 10)\ncat = random.normal(9, 0.1, 10)\nchocolate = random.normal(-1, 0.1, 10)\n\nprint(\"Similarity between 'cat' and 'dog':\")\nprint(cosine_similarity(cat, dog))\nprint(\"\\nSimilarity between 'cat' and 'chocolate':\")\nprint(cosine_similarity(cat, chocolate))\nprint(\"\\nSimilarity between 'dog' and 'chocolate':\")\nprint(cosine_similarity(cat, chocolate))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimilarity between 'cat' and 'dog':\n0.9998795270450233\n\nSimilarity between 'cat' and 'chocolate':\n-0.9948113184001908\n\nSimilarity between 'dog' and 'chocolate':\n-0.9948113184001908\n```\n:::\n:::\n\n\nIf we extend this logic out to the comparison between research paper abstracts, and my list of keywords, then we wouldn't necessarily need the keywords themselves to be present in the text. All we would need is for the semantic meaning of the words in the text to be close enough to the semantics of my keywords so that the text is selected for as relevant, relative to all the other abstracts I collected on a given day.\n\nBut even though cosine similarity is the most popular tool for this job, it isn't the only way. And maybe not even the best way.\n\nAnother method is to find the Euclidean distance,\n\nIn math notation, this is represented as:\n\n$$\nd = \\sqrt{\\sum_{i=1}^{n}(a_i - b_i)^2}\n$$\n\nAnd in python:\n\n::: {#9838b6de .cell execution_count=5}\n``` {.python .cell-code}\nfrom numpy import sqrt\n\ndef euclidean_distance(a, b):\n  sum = 0\n  for a_i, b_i in zip(a, b):\n    sum += (a_i - b_i) ** 2\n  return sqrt(sum)\n```\n:::\n\n\nLet's see how this function performs on our cat, dog, and chocolate vectors:\n\n::: {#ad9ed07a .cell execution_count=6}\n``` {.python .cell-code}\nfrom numpy import dot, linalg, sqrt, random\n\ndef cosine_similarity(a, b):\n  a_dot_b = dot(a, b)\n  a_norm = linalg.norm(a)\n  b_norm = linalg.norm(b)\n  return a_dot_b / (a_norm * b_norm)\n\ndef euclidean_distance(a, b):\n  sum = 0\n  for a_i, b_i in zip(a, b):\n    sum += (a_i - b_i) ** 2\n  return sqrt(sum)\n\nrandom.seed(69)\ndog = random.normal(9, 0.1, 10)\ncat = random.normal(9, 0.1, 10)\nchocolate = random.normal(-1, 0.1, 10)\n\nprint(\"\\nDistance between 'cat' and 'dog':\")\nprint(euclidean_distance(cat, dog))\nprint(\"\\nDistance between 'cat' and 'chocolate':\")\nprint(euclidean_distance(cat, chocolate))\nprint(\"\\nDistance between 'dog' and 'chocolate':\")\nprint(euclidean_distance(cat, chocolate))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nDistance between 'cat' and 'dog':\n0.531369027749265\n\nDistance between 'cat' and 'chocolate':\n31.609471832084054\n\nDistance between 'dog' and 'chocolate':\n31.609471832084054\n```\n:::\n:::\n\n\nAgain this makes sense. We can see that the distance between 'cat' and 'dog' is relatively small, wheras the distances between each word and 'chocolate' is relatively large.\n\nBut so far we've been testing these algorithms on very simple data. Each of these vectors has only ten dimensions.\n\nHow would these algorithms hold up with realistic data? For example, vector embeddings generated with OpenAI's embeddings model create vectors with 1536 dimension.\n\nAgain we'll use a hack to get us there for demonstration purposes. Let's change these ten dimensional vectors into 1500-dimensional vectors.\n\n::: {#1f5fa560 .cell execution_count=7}\n``` {.python .cell-code}\nfrom numpy import dot, linalg, sqrt, random\n\ndef cosine_similarity(a, b):\n  a_dot_b = dot(a, b)\n  a_norm = linalg.norm(a)\n  b_norm = linalg.norm(b)\n  return a_dot_b / (a_norm * b_norm)\n\ndef euclidean_distance(a, b):\n  sum = 0\n  for a_i, b_i in zip(a, b):\n    sum += (a_i - b_i) ** 2\n  return sqrt(sum)\n\nrandom.seed(69)\ndog = random.normal(9, 0.1, 1500)\ncat = random.normal(9, 0.1, 1500)\nchocolate = random.normal(-1, 0.1, 1500)\n\nprint(\"Similarity between 'cat' and 'dog':\")\nprint(cosine_similarity(cat, dog))\nprint(\"\\nSimilarity between 'cat' and 'chocolate':\")\nprint(cosine_similarity(cat, chocolate))\nprint(\"\\nSimilarity between 'dog' and 'chocolate':\")\nprint(cosine_similarity(cat, chocolate))\n\nprint(\"\\nDistance between 'cat' and 'dog':\")\nprint(euclidean_distance(cat, dog))\nprint(\"\\nDistance between 'cat' and 'chocolate':\")\nprint(euclidean_distance(cat, chocolate))\nprint(\"\\nDistance between 'dog' and 'chocolate':\")\nprint(euclidean_distance(cat, chocolate))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimilarity between 'cat' and 'dog':\n0.9998746586092114\n\nSimilarity between 'cat' and 'chocolate':\n-0.9950888019421268\n\nSimilarity between 'dog' and 'chocolate':\n-0.9950888019421268\n\nDistance between 'cat' and 'dog':\n5.52021942675591\n\nDistance between 'cat' and 'chocolate':\n387.32715847990386\n\nDistance between 'dog' and 'chocolate':\n387.32715847990386\n```\n:::\n:::\n\n\nNow let's use some statistical methods to see how the quality of our low-dimensional\nsimilarity/distance scores, and our high-dimensional similarity/distance scores stack up.\n\n::: {#53e58365 .cell execution_count=8}\n``` {.python .cell-code}\nfrom numpy import (\n  corrcoef, dot, linalg, sqrt,\n  random, std, var, sqrt\n)\n\ndef cosine_similarity(a, b):\n  a_dot_b = dot(a, b)\n  a_norm = linalg.norm(a)\n  b_norm = linalg.norm(b)\n  return a_dot_b / (a_norm * b_norm)\n\ndef euclidean_distance(a, b):\n  sum = 0\n  for a_i, b_i in zip(a, b):\n    sum += (a_i - b_i) ** 2\n  return sqrt(sum)\n\ndef diem(a, b, v_min, v_max, n_dim):\n    ed = sqrt(sum((ai - bi)**2 for ai, bi in zip(a, b)))\n    e_d = sqrt(n_dim) * (v_max - v_min) / 6  # Expected distance\n    sigma_ed = sqrt((v_max - v_min)**2 / 12)\n    return (v_max - v_min) / sigma_ed**2 * (ed - e_d)\n\n# Generate random vectors and compute metrics\nrandom.seed(69)\ndog = random.normal(9, 0.1, 1500)\ncat = random.normal(9, 0.1, 1500)\nchocolate = random.normal(-1, 0.1, 1500)\n\ncosine_cat_dog = cosine_similarity(cat, dog)\neuclidean_cat_dog = euclidean_distance(cat, dog)\ndiem_cat_dog = diem(cat, dog, -1, 9, 1500)\n\nprint(f\"Cosine Similarity: {cosine_cat_dog}\")\nprint(f\"Euclidean Distance: {euclidean_cat_dog}\")\nprint(f\"DIEM: {diem_cat_dog}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCosine Similarity: 0.9998746586092114\nEuclidean Distance: 5.52021942675591\nDIEM: -70.83540361204122\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}